// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

// ===== MOD√àLES PRINCIPAUX =====

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  username  String   @unique
  password  String?  // Peut √™tre null pour les comptes OAuth
  avatar    String?
  bio       String?
  isOnline  Boolean  @default(false)
  lastSeen  DateTime @default(now())
  
  // üîê Authentification et v√©rification
  isEmailVerified Boolean  @default(false)
  emailVerificationCode String?
  emailVerificationExpiry DateTime?
  resetPasswordToken String?
  resetPasswordExpiry DateTime?
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  profile     UserProfile?
  teams       TeamMember[]
  ownedTeams  Team[]        @relation("TeamOwner")
  messages    Message[]
  rooms       RoomMember[]
  ownedRooms  Room[]        @relation("RoomOwner")
  sentInvitations Invitation[] @relation("InvitationSender")
  voiceConnections VoiceConnection[]
  permissions UserPermission[]
  socialAccounts SocialAccount[]
  refreshTokens RefreshToken[]

  @@index([email])
  @@index([username])
  @@index([isOnline])
  @@index([lastSeen])
  @@index([emailVerificationCode])
  @@index([resetPasswordToken])
  @@map("users")
}

model UserProfile {
  id          String @id @default(cuid())
  userId      String @unique
  firstName   String?
  lastName    String?
  phone       String?
  location    String?
  website     String?
  socialLinks String? // JSON stock√© comme texte en SQLite
  preferences String? // JSON stock√© comme texte en SQLite
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_profiles")
}

// ===== GESTION DES √âQUIPES =====

model Team {
  id          String   @id @default(cuid())
  name        String
  description String?
  avatar      String?
  isPublic    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  ownerId     String

  // Relations
  owner     User         @relation("TeamOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  members   TeamMember[]
  rooms     Room[]
  invitations Invitation[]

  @@index([ownerId])
  @@map("teams")
}

model TeamMember {
  id       String   @id @default(cuid())
  userId   String
  teamId   String
  role     String @default("MEMBER")
  joinedAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@unique([userId, teamId])
  @@map("team_members")
}

// SQLite ne supporte pas les enums, on utilise des strings
// enum TeamRole {
//   OWNER
//   ADMIN
//   MODERATOR
//   MEMBER
// }

// ===== SYST√àME DE CHAT =====

model Room {
  id          String   @id @default(cuid())
  name        String
  description String?
  avatar      String?
  isPrivate   Boolean  @default(false)
  isDirect    Boolean  @default(false)
  maxMembers  Int      @default(100)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  teamId      String?
  ownerId     String

  // Relations
  owner     User         @relation("RoomOwner", fields: [ownerId], references: [id], onDelete: Cascade)
  team      Team?        @relation(fields: [teamId], references: [id], onDelete: Cascade)
  members   RoomMember[]
  messages  Message[]
  pinnedMessages PinnedMessage[]
  voiceConnections VoiceConnection[]

  @@index([teamId])
  @@index([ownerId])
  @@index([isDirect])
  @@map("rooms")
}

model RoomMember {
  id       String   @id @default(cuid())
  userId   String
  roomId   String
  role     String @default("MEMBER")
  joinedAt DateTime @default(now())
  isMuted  Boolean  @default(false)

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  room Room @relation(fields: [roomId], references: [id], onDelete: Cascade)

  @@unique([userId, roomId])
  @@map("room_members")
}

// SQLite ne supporte pas les enums, on utilise des strings
// enum RoomRole {
//   OWNER
//   ADMIN
//   MODERATOR
//   MEMBER
// }

// ===== MESSAGES ET NOTIFICATIONS =====

model Message {
  id        String   @id @default(cuid())
  content   String
  type      String @default("TEXT")
  metadata  String? // JSON stock√© comme texte en SQLite
  isEdited  Boolean  @default(false)
  isDeleted Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String
  roomId    String
  replyToId String?
  parentId  String?

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  replyTo     Message? @relation("MessageReplies", fields: [replyToId], references: [id])
  replies     Message[] @relation("MessageReplies")
  parent      Message? @relation("MessageThread", fields: [parentId], references: [id])
  thread      Message[] @relation("MessageThread")
  room        Room     @relation(fields: [roomId], references: [id], onDelete: Cascade)
  pinnedIn    PinnedMessage[]

  @@index([roomId])
  @@index([userId])
  @@index([createdAt])
  @@map("messages")
}

// SQLite ne supporte pas les enums, on utilise des strings
// enum MessageType {
//   TEXT
//   IMAGE
//   FILE
//   AUDIO
//   VIDEO
//   SYSTEM
// }

model PinnedMessage {
  id        String   @id @default(cuid())
  messageId String
  roomId    String
  pinnedBy  String
  pinnedAt  DateTime @default(now())

  // Relations
  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  room    Room   @relation(fields: [roomId], references: [id], onDelete: Cascade)

  @@unique([messageId, roomId])
  @@map("pinned_messages")
}

// ===== INVITATIONS ET NOTIFICATIONS =====

model Invitation {
  id        String   @id @default(cuid())
  email     String
  teamId    String?
  roomId    String?
  role      String   @default("MEMBER")
  status    String @default("PENDING")
  expiresAt DateTime
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  senderId  String

  // Relations
  sender User  @relation("InvitationSender", fields: [senderId], references: [id], onDelete: Cascade)
  team   Team? @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@index([expiresAt])
  @@map("invitations")
}

// SQLite ne supporte pas les enums, on utilise des strings
// enum InvitationStatus {
//   PENDING
//   ACCEPTED
//   DECLINED
//   EXPIRED
// }

// üå∏ Mod√®le Connexion Vocale
model VoiceConnection {
  id        String   @id @default(cuid())
  userId    String
  roomId    String
  isActive  Boolean  @default(true)
  joinedAt  DateTime @default(now())
  leftAt    DateTime?

  // Relations
  user      User @relation(fields: [userId], references: [id], onDelete: Cascade)
  room      Room @relation(fields: [roomId], references: [id], onDelete: Cascade)

  @@unique([userId, roomId])
  @@map("voice_connections")
}

// üå∏ Mod√®le Permission Utilisateur
model UserPermission {
  id       String @id @default(cuid())
  userId   String
  permission String
  granted  Boolean @default(true)
  grantedAt DateTime @default(now())
  grantedBy String?

  // Relations
  user     User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, permission])
  @@map("user_permissions")
}

// üå∏ Mod√®le Session
model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  isActive  Boolean  @default(true)

  @@map("sessions")
}

// üå∏ Mod√®le Audit Log
model AuditLog {
  id          String      @id @default(cuid())
  userId      String?
  action      String
  resource    String?
  resourceId  String?
  details     String? // JSON stock√© comme texte en SQLite
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime    @default(now())

  @@map("audit_logs")
}

// üîê AUTHENTIFICATION AVANC√âE

// Mod√®le pour les comptes sociaux (OAuth)
model SocialAccount {
  id         String @id @default(cuid())
  userId     String
  provider   String // "google", "apple", "steam"
  providerId String // ID fourni par le provider
  email      String?
  name       String?
  avatar     String?
  accessToken String?
  refreshToken String?
  expiresAt  DateTime?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerId])
  @@unique([provider, userId])
  @@index([provider])
  @@map("social_accounts")
}

// Mod√®le pour les refresh tokens
model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
  isRevoked Boolean  @default(false)
  deviceInfo String? // JSON avec info sur l'appareil

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("refresh_tokens")
}

// üå∏ √ânum√©rations
// SQLite ne supporte pas les enums, on utilise des strings
// enum UserStatus {
//   ONLINE
//   AWAY
//   DO_NOT_DISTURB
//   OFFLINE
// }

// SQLite ne supporte pas les enums, on utilise des strings
// enum PermissionType {
//   CREATE_ROOM
//   DELETE_ROOM
//   MANAGE_USERS
//   MANAGE_ROLES
//   SEND_MESSAGES
//   DELETE_MESSAGES
//   JOIN_VOICE
//   MANAGE_VOICE
//   VIEW_AUDIT_LOGS
//   MANAGE_PERMISSIONS
// }

// SQLite ne supporte pas les enums, on utilise des strings
// enum SocialProvider {
//   GOOGLE
//   APPLE
//   STEAM
// }
